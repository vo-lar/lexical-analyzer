#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include "lex_analyze.h"


#define   MAXBUF    100

using namespace std;

struct node keywords[MAX];

/*对关键字表进行初始化，div,mod,and,or也作为关键字处理*/
/*最小的token是30*/
void init()
{
    int j;
    for (j = 0; j < MAX; j++){
        strcpy(keywords[j].lexptr, key[j]);
        keywords[j].token = j + 30;
    }
}

/***************对关键字进行搜索**************/
int Iskeyword(node keyword[],char* ch) {
    int i;
    for (i = 0; i < MAX; i++) {
        if ((strcmp(keyword[i].lexptr, ch)) == 0)
            break;
    }
    if (i < MAX) 
        return  keyword[i].token;
    else 
        return 0;
}

/*****************判断是否为字母*****************/
bool IsLetter(char c)
{
    if ((c <= 'z') && (c >= 'a') || (c <= 'Z') && (c >= 'A')) 
        return 1;
    else 
        return 0;
}

/*************判断是否为数字**************/
bool IsDigit(char c) {
    if (c >= '0' && c <= '9') 
        return 1;
    else 
        return 0;
}

/*判断是否为单个运算符*/
string IsOp(char ch, int Line_No) {
    stringstream ss;
    int i = 0;
    for (; i < MAX; i++) {
        cout << ch << endl;
        if (op[i].myoperator[0] == ch)
            break;
    }
    if (i < MAX) {
        ss << op[i].myoperator << "\t\t" << op[i].number << "\t\t" << op[i].type << endl;
    }
    else {
        ss << "在第" << Line_No << "行无法识别的字符\t" << ch << endl;
    }
    return ss.str();
}


/***************分析程序**************/
void text_analyse(string input, string output) {

    fstream fin, fout;
    fin.open(input.c_str(), ios::in | ios::binary);
    fout.open(output.c_str(), ios::out | ios::binary);
    if (!fin.is_open()) {
        cout << "无法打开需要读取的文件" << endl;
        return;
    }

    char arr[MAXBUF];
    int j = 0;
    char ch = ' ';             /*存放读入当前的输入字符*/
    int Line_NO = 0;                /*纪录行号*/
    while ((ch = (fin).get()) != EOF) {
        /*空格、tab*/
        if (ch == ' ' || ch == '\t') {
            continue;
        }
        else if (ch == '\n') { Line_NO++; }
        /*字符串*/
        else if (IsLetter(ch)) {
            while (IsLetter(ch) | IsDigit(ch) | (ch == '_')) {
                if ((ch <= 'Z') && (ch >= 'A'))
                    ch = ch + 32;
                arr[j] = ch;
                j++;
                ch = (fin).get();
            }
            fin.seekg(-1, ios::cur);
            arr[j] = '\0';
            j = 0;
            if (Iskeyword(keywords, arr)){
                fout << arr << "\t\t" << Iskeyword(keywords, arr) << "\t\t" << "关键字" << endl;
            }
            else
                fout << arr << "\t\t" << 1 << "\t\t" << "标识符" << endl;
        }
        /*数字*/
        else if (IsDigit(ch)) {
            int s = 0;
            while (IsDigit(ch) | IsLetter(ch)) {
                if (IsLetter(ch)) {
                    arr[j] = ch;
                    j++;
                    ch = (fin).get();
                    s = 1;
                }
                else if (IsDigit(ch)) {
                    arr[j] = ch;
                    j++;
                    ch = (fin).get();
                }
            }
            (fin).seekg(-1, ios::cur);
            arr[j] = '\0';
            j = 0;
            if (s == 0)
                fout << arr << "\t\t" << 2 << "\t\t" << "无符号整数" << endl;
            else if (s == 1)
                fout << arr << "\t\t" << 3 << "\t\t" << "无法试别" << endl;
        }
        else {
            /*>,>=*/
            if (ch == '>') {
                ch = fin.get();
                if (ch == '=')
                    fout << ">=" << "\t\t" << 41 << "\t\t" << "运算符" << endl;
                else {
                    fout << ">" << "\t\t" << 41 << "\t\t" << "运算符" << endl;
                    fin.seekg(-1, ios::cur);
                }
            }
            /*<,<=,<>*/
            else if (ch == '<') {
                ch = (fin).get();
                if (ch == '=')
                    fout << "<=" << "\t\t" << 41 << "\t\t" << "运算符" << endl;
                else if (ch == '>')
                    fout << "<>" << "\t\t" << 41 << "\t\t" << "运算符" << endl;
                else {
                    fout << "<" << "\t\t" << 41 << "\t\t" << "运算符" << endl;
                    (fin).seekg(-1, ios::cur);
                }
            }
            /*单符号*/
            else {
                IsOp(ch, Line_NO);
            }
            
        }
    }

    fin.close();
    fout.close();

}